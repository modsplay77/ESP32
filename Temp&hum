
#include <ThingSpeak.h>
#include <WiFi.h>
#include <WiFiClient.h>
#include <WiFiServer.h>
#include <WiFiClientSecure.h>
#include <Wire.h>
#include <DFRobot_SHT3x.h>

// Usuarios y claves para la conexión WiFi
char ssid[] = "Livebox6-767D"; //SSID - Red WiFi a la que me conecto
char pass[] = "******"; // Passowrd de la red WiFi
int status = WL_IDLE_STATUS;
WiFiClient client;


float temp;
float hum ;
int inicio = 1;

// Variables para definir la conexión con ThingSpeak
unsigned long myChannelNumber = ******; //Código de canal de Things Speak
const char * myWriteAPIKey = "*********"; // Indicar aquí el código de escritura de ThingSpeak


//DFRobot_SHT3x sht3x(&Wire,/*address=*/0x45,/*RST=*/4);
DFRobot_SHT3x   sht3x;


void setup() {
  Serial.begin(115200);
  DFRobot_SHT3x::sRHAndTemp_t data = sht3x.readTemperatureAndHumidity(sht3x.eRepeatability_High);
//Imprimir mensaje de conexión a la red Wifi
WiFi.begin(ssid, pass); //Se inicia la conexión al Wifi
ThingSpeak.begin(client); // Inicia ThingSpeak
  WiFi.mode(WIFI_STA);
    Serial.println("Conectando...");
 delay (2000);

  

//Minetras se conecta imprimirá ...
while(WiFi.status() != WL_CONNECTED){
  delay(5000);
  
  
//Ya que se estableció la conexión al Wifi se imprime conexión establecida

    Serial.println("Conectado");
    delay (2000);
     Serial.println(WiFi.localIP());  
   
 delay (2000);
} 

  //Initialize the chip
  while (sht3x.begin() != 0) {
    Serial.println("Failed to Initialize the chip, please confirm the wire connection");
    delay(1000);
  }
  /**
   * readSerialNumber Read the serial number of the chip.
   * @return Return 32-digit serial number.
   */
  Serial.print("Chip serial number");
  Serial.println(sht3x.readSerialNumber());

  /**
   * softReset Send command resets via IIC, enter the chip's default mode single-measure mode, 
   * turn off the heater, and clear the alert of the ALERT pin.
   * @return Read the register status to determine whether the command was executed successfully, 
   * and return true indicates success.
   */
   if(!sht3x.softReset()){
     Serial.println("Failed to Initialize the chip....");
   }

  /**
   * heaterEnable(): Turn on the heater inside the chip to enable the sensor get correct humidity value in wet environments.
   * @return Read the status of the register to determine whether the command was executed successfully,
   * and return true indicates success.
   * @note Heaters should be used in wet environments, and other cases of use will result in incorrect readings
   */

  //if(!sht3x.heaterEnable()){
  // Serial.println("Failed to turn on the heater....");
  //}
  Serial.println("------------------Read adta in single measurement mode-----------------------");
  
  if(inicio == 1){

    Serial.println("Sistema listo");
    delay (2000);
    inicio = 0;

}
}

void loop() {
delay (2000);
//Imprimimos en serial
  Serial.print("Ambient Temperature(°C):");
  Serial.print(sht3x.getTemperatureC());//leemos temp
  Serial.println(" ºC");
  float temp =  (sht3x.getTemperatureC());
    delay (2000);

  
  Serial.print("Relative Humidity(%RH):");
  Serial.print(sht3x.getHumidityRH());
  Serial.println(" %RH");
      float hum = (sht3x.getHumidityRH());
  delay (2000);

 update();

}

void update(){
  float temp =  (sht3x.getTemperatureC());
  float hum = (sht3x.getHumidityRH());

  int mensaje = ThingSpeak.writeFields(myChannelNumber, myWriteAPIKey);
  ThingSpeak.setField(1, temp); 
  ThingSpeak.setField(2, hum); 

if (mensaje == 200){
  Serial.println("Canal Update");
    retraso();
}else{
      Serial.println("ERROR: " + String(mensaje));

    Serial.println("ERROR envio");
    }

}

void retraso(){
 // Añadimos un retraso para limtitar el número de escrituras en Thinhspeak
 Serial.println("Proximo update: 1 hora");
int duracionDelay = 3600; //En segundos, actualización, cada hora
for (int i = 0; i < duracionDelay; i ++) { //Esto es debido a que el máximo que el Arduino puede procesar con precisión es 5000ms o 5 segundos

  while(duracionDelay != 0);
  return;
  } 
}
